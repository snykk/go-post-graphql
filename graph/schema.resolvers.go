package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"errors"

	"github.com/snykk/go-post-graphql/graph/model"
)

// CreateUser is the resolver for creating a new user
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUserInput) (*model.User, error) {
	var user model.User
	err := r.Resolver.DB.QueryRow(ctx,
		"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email",
		input.Name, input.Email,
	).Scan(&user.ID, &user.Name, &user.Email)

	if err != nil {
		return nil, err
	}
	return &user, nil
}

// CreatePost is the resolver for creating a new post
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPostInput) (*model.Post, error) {
	var post model.Post
	err := r.Resolver.DB.QueryRow(ctx,
		"INSERT INTO posts (title, content, author_id) VALUES ($1, $2, $3) RETURNING id, title, content",
		input.Title, input.Content, input.AuthorID,
	).Scan(&post.ID, &post.Title, &post.Content)

	if err != nil {
		return nil, err
	}

	// Fetch the author details
	var author model.User
	err = r.Resolver.DB.QueryRow(ctx, "SELECT id, name, email FROM users WHERE id=$1", input.AuthorID).
		Scan(&author.ID, &author.Name, &author.Email)

	if err != nil {
		return nil, err
	}

	post.Author = &author
	return &post, nil
}

// CreateComment is the resolver for creating a new comment
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewCommentInput) (*model.Comment, error) {
	// Fetch the post details
	var post model.Post
	err := r.Resolver.DB.QueryRow(ctx, "SELECT id, title, content FROM posts WHERE id=$1", input.PostID).
		Scan(&post.ID, &post.Title, &post.Content)

	if err != nil {
		return nil, errors.New("Error fetch post with id: " + input.PostID)
	}

	// Fetch the author details
	var author model.User
	err = r.Resolver.DB.QueryRow(ctx, "SELECT id, name, email FROM users WHERE id=$1", input.AuthorID).
		Scan(&author.ID, &author.Name, &author.Email)

	if err != nil {
		return nil, errors.New("Error fetch author with id: " + input.AuthorID)
	}

	var comment model.Comment
	err = r.Resolver.DB.QueryRow(ctx,
		"INSERT INTO comments (text, post_id, author_id) VALUES ($1, $2, $3) RETURNING id, text",
		input.Text, input.PostID, input.AuthorID,
	).Scan(&comment.ID, &comment.Text)

	if err != nil {
		return nil, err
	}

	comment.Post = &post
	comment.Author = &author
	return &comment, nil
}

// GetUsers is the resolver for getting all users
func (r *queryResolver) GetUsers(ctx context.Context) ([]*model.User, error) {
	rows, err := r.Resolver.DB.Query(ctx, "SELECT id, name, email FROM users")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var users []*model.User
	for rows.Next() {
		var user model.User
		if err := rows.Scan(&user.ID, &user.Name, &user.Email); err != nil {
			return nil, err
		}
		users = append(users, &user)
	}
	return users, nil
}

// GetPosts is the resolver for getting all posts
func (r *queryResolver) GetPosts(ctx context.Context) ([]*model.Post, error) {
	// Fetch all posts along with their authors
	rows, err := r.Resolver.DB.Query(ctx, `
		SELECT p.id, p.title, p.content, u.id, u.name, u.email
		FROM posts p
		JOIN users u ON p.author_id = u.id
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var posts []*model.Post
	postMap := make(map[string]*model.Post)

	for rows.Next() {
		var post model.Post
		var author model.User

		if err := rows.Scan(&post.ID, &post.Title, &post.Content, &author.ID, &author.Name, &author.Email); err != nil {
			return nil, err
		}

		post.Author = &author
		post.Comments = []*model.Comment{} // Initialize empty comments slice
		posts = append(posts, &post)
		postMap[post.ID] = &post
	}

	// Fetch all comments in one query
	commentRows, err := r.Resolver.DB.Query(ctx, `
		SELECT c.id, c.text, c.post_id, u.id, u.name
		FROM comments c
		JOIN users u ON c.author_id = u.id
	`)
	if err != nil {
		return nil, err
	}
	defer commentRows.Close()

	for commentRows.Next() {
		var comment model.Comment
		var postID string
		var author model.User

		if err := commentRows.Scan(&comment.ID, &comment.Text, &postID, &author.ID, &author.Name); err != nil {
			return nil, err
		}

		comment.Author = &author

		// Assign comment to the correct post
		if post, exists := postMap[postID]; exists {
			post.Comments = append(post.Comments, &comment)
		}
	}

	return posts, nil
}

// GetComments is the resolver for getting all comments
func (r *queryResolver) GetComments(ctx context.Context) ([]*model.Comment, error) {
	// Execute a single query with JOIN to avoid multiple database queries inside the loop
	rows, err := r.Resolver.DB.Query(ctx, `
		SELECT c.id, c.text,
		       p.id, p.title, p.content,
		       u.id, u.name, u.email
		FROM comments c
		JOIN posts p ON c.post_id = p.id
		JOIN users u ON c.author_id = u.id
	`)
	if err != nil {
		return nil, err
	}
	// Ensure rows are closed after processing
	defer rows.Close()

	var comments []*model.Comment
	for rows.Next() {
		var comment model.Comment
		var post model.Post
		var author model.User

		// Scan all fields at once to avoid extra queries
		if err := rows.Scan(&comment.ID, &comment.Text,
			&post.ID, &post.Title, &post.Content,
			&author.ID, &author.Name, &author.Email); err != nil {
			return nil, err
		}

		// Assign the post and author objects to the comment
		comment.Post = &post
		comment.Author = &author
		comments = append(comments, &comment)
	}

	// Return the list of comments along with their associated posts and authors
	return comments, nil
}

// GetUserByID is the resolver for getting a user by ID
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	err := r.Resolver.DB.QueryRow(ctx, "SELECT id, name, email FROM users WHERE id=$1", id).
		Scan(&user.ID, &user.Name, &user.Email)

	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetUserByEmail is the resolver for getting a user by email
func (r *queryResolver) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	var user model.User
	err := r.Resolver.DB.QueryRow(ctx, "SELECT id, name, email FROM users WHERE email=$1", email).
		Scan(&user.ID, &user.Name, &user.Email)

	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetPostByID is the resolver for getting a post by ID
func (r *queryResolver) GetPostByID(ctx context.Context, id string) (*model.Post, error) {
	var post model.Post
	var author model.User

	err := r.Resolver.DB.QueryRow(ctx, `
        SELECT p.id, p.title, p.content, u.id, u.name, u.email
        FROM posts p
        JOIN users u ON p.author_id = u.id
        WHERE p.id = $1
    `, id).Scan(&post.ID, &post.Title, &post.Content, &author.ID, &author.Name, &author.Email)

	if err != nil {
		return nil, err
	}

	post.Author = &author
	return &post, nil
}

// GetCommentByID is the resolver for getting a comment by ID
func (r *queryResolver) GetCommentByID(ctx context.Context, id string) (*model.Comment, error) {
	var comment model.Comment
	var post model.Post
	var author model.User

	err := r.Resolver.DB.QueryRow(ctx, `
        SELECT c.id, c.text, p.id, p.title, u.id, u.name
        FROM comments c
        JOIN posts p ON c.post_id = p.id
        JOIN users u ON c.author_id = u.id
        WHERE c.id = $1
    `, id).Scan(&comment.ID, &comment.Text, &post.ID, &post.Title, &author.ID, &author.Name)

	if err != nil {
		return nil, err
	}

	comment.Post = &post
	comment.Author = &author
	return &comment, nil
}

// GetCommentsByPostID is the resolver for getting comments by Post ID
func (r *queryResolver) GetCommentsByPostID(ctx context.Context, postID string) ([]*model.Comment, error) {
	rows, err := r.Resolver.DB.Query(ctx, `
        SELECT c.id, c.text, u.id, u.name 
        FROM comments c
        JOIN users u ON c.author_id = u.id
        WHERE c.post_id = $1
    `, postID)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var comments []*model.Comment
	for rows.Next() {
		var comment model.Comment
		var author model.User

		if err := rows.Scan(&comment.ID, &comment.Text, &author.ID, &author.Name); err != nil {
			return nil, err
		}

		comment.Author = &author
		comments = append(comments, &comment)
	}

	return comments, nil
}

// GetCommentsByAuthorID is the resolver for getting comments by Author ID
func (r *queryResolver) GetCommentsByAuthorID(ctx context.Context, authorID string) ([]*model.Comment, error) {
	rows, err := r.Resolver.DB.Query(ctx, `
        SELECT c.id, c.text, p.id, p.title
        FROM comments c
        JOIN posts p ON c.post_id = p.id
        WHERE c.author_id = $1
    `, authorID)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var comments []*model.Comment
	for rows.Next() {
		var comment model.Comment
		var post model.Post

		if err := rows.Scan(&comment.ID, &comment.Text, &post.ID, &post.Title); err != nil {
			return nil, err
		}

		comment.Post = &post
		comments = append(comments, &comment)
	}

	return comments, nil
}

// GetPostsByAuthorID is the resolver for getting posts by Author ID
func (r *queryResolver) GetPostsByAuthorID(ctx context.Context, authorID string) ([]*model.Post, error) {
	rows, err := r.Resolver.DB.Query(ctx, `
        SELECT id, title, content 
        FROM posts 
        WHERE author_id = $1
    `, authorID)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var posts []*model.Post
	for rows.Next() {
		var post model.Post

		if err := rows.Scan(&post.ID, &post.Title, &post.Content); err != nil {
			return nil, err
		}

		posts = append(posts, &post)
	}

	return posts, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
